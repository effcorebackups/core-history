

О проекте
=====================================================================

Тип                 : система/фреймворк управления содержимым
Автор               : Рысевец Максим Владимирович
Разработчик         : Рысевец Максим Владимирович
Первый выпуск       : 01.01.2021
Написан на          : PHP
Операционная система: UNIX (Apple macOS, FreeBSD), Linux, Microsoft Windows
Лицензия            : проприетарное программное обеспечение
Сайт                : http://effcore.com

EFFCORE — это мини-CMS (система управления содержимым) и мини-CMF (фреймворк
управления содержимым) нового поколения, разработанная в промежутке между
2017 и 2021 годам.
Вобрала в себя новые возможности Web 2.0/3.0.
Использует такие технологии как: HTML5, CSS3, IP v6, SVG, SMIL,
UTF8, UTC, WAI-ARIA, NoSQL, Markdown, UML, PSR-0.

Может использоваться в качестве инструмента для построения
сайтов простыми пользователями, а также в качестве инструмента для
разработки сайтов, порталов и сервисов профессиональными веб-разработчиками.

Название системы является акронимом и происходит от фразы "effective core".
Система была разработана с нуля. Её главный принцип — полное отсутствие
стороннего кода (для исключения правовых претензий и любых других ограничений,
связанных с заимствованием),
а также сторонних идей (для поиска новых инновационных решений).

Толчком к созданию системы послужила массовая деградация в развитии
Open Source проектов. Если рассмотреть данную ситуацию, то можно увидеть,
что разработчиками таких проектов являются люди разного уровня подготовки,
расположенные в разных частях планеты. Несогласованность в их действиях, а
также разные взгляды на решения в проекте являются лишь частью проблемы.
Второй существенный недостаток — это экстенсивный путь развития кода таких
проектов в противовес интенсивному, то есть вместо того чтобы создавать
собственный код, они, как правило, берут очередную библиотеку, написанную
непонятно кем и непонятно где, и пытаются совместить её с группой таких же
библиотек, никак между собой не согласованных и имеющих избыточный и не до
конца протестированный функционал.
Как следствие, в результате получается набор непонятных и
не согласованных библиотек с плохо протестированным избыточным
функционалом, который постоянно растёт в объёме.
К сожалению, многие разработчики "погрязли" в таком коде
и пытаются отрицать очевидные вещи.

Основной упор в системе сделан на получение максимальной производительности.
В качестве оценочного критерия было принято простое и понятное условие:
система, установленная на хостинге с самым дешёвым тарифным планом (от
~3-5$ в месяц), который соответствует минимальным требованиям установки,
должна генерировать главную страницу за время 0,005 секунды (с включённым
OPCache) или 0,05 секунды (с выключенным OPCache), что в первом случае
позволит обслуживать до ~200 клиентов в секунду, а во втором — до ~20 (без
учёта параллельной загрузки подключаемых файлов).


Управление содержимым
---------------------------------------------------------------------

Управление содержимым в системе ориентировано на прямую вставку
любого доступного блока (меню, текст, формы, хлебные крошки и другие)
непосредственно в макет редактируемой страницы. При создании новой страницы
пользователю предоставляется выбор макета, и каждая новая страница может иметь
своё уникальное расположение блоков.


Файловая организация
---------------------------------------------------------------------

В каждом модуле всё необходимое для frontend разработки
располагается в директории "module_*/frontend",
а для backend разработки — в директории "module_*/backend".
Все NoSQL-данные располагаются в директории "module_*/data".

Фактически, работа файлов не зависит от их расположения и
при необходимости они всё равно будут найдены и обработаны, а их
расположение в определённых директориях — это лишь организационная
мера, призванная облегчить работу с системой.


Архитектура
---------------------------------------------------------------------

Архитектура выполнена по классической схеме MVC.
Является гибридной системой из подобия NoSQL и SQL-хранилищ.
В свою очередь NoSQL-подсистема реализует гибридную документ-ориентированную
и объектно-ориентированную модель на основе набора классов-паттернов.

Код системы адаптирован под повторное использование.
Система состоит из множества маленьких классов/классов-паттернов,
содержащих в себе в среднем от 3 до 15 методов, которые, в свою очередь,
состоят из 3-7 строк кода.

Благодаря "матричному" стилю вёрстки восприятие кода существенно
облегчается (в некоторых местах напоминает синтаксис Python), а
грамотное расположение файлов в системе позволяет определить их
назначение, не прибегая к какой-либо документации.
Также всё, что казалось сложным, было отвергнуто или переделано.
Каждая функция итеративно совершенствовалась от 3 до 10 раз.
Функциональное тестирование выполнялось на всём множестве
комбинаторных перестановок.

Имеет встроенный парсер и загрузчик классов PSR-0, благодаря чему
для добавления новой библиотеки (набора классов) достаточно поместить
содержащие их файлы на веб-сервер и сбросить кэш, после чего они
становятся доступными из любого места системы.
В состав системы входит страница с UML-диаграммой всех классов
и ссылкой для загрузки JSON-файла с описанием классов в формате
программы StarUML.


Безопасность
---------------------------------------------------------------------

Также немаловажным фактором в системе является безопасность.
В качестве решений для повышения уровня безопасности были использованы:
- возможность работы без JS;
- подписанные ключом пользовательские сессии;
- подписанные ключом валидационные идентификаторы формы;
- использование препарированных SQL-запросов;
- фильтрация данных, вводимых пользователем в поля формы;
- фильтрация аргументов URL;
- единая точка входа любого HTTP-запроса (single entry point),
  как результат — отсутствие негативных воздействий при неверной настройке
  веб-сервера (".htaccess", "web.config");
- возможность создания нового типа файла с полным контролем доступа;
- возможность получения хэша сборки страницы в консоли системы;
- базовый модуль CAPTCHA.

Детерминизм в работе системы — ещё один немаловажный фактор.
При одних и тех же входных параметрах должен выдаваться один и тот же результат
вне зависимости от платформы, и как результат — полный отказ от функций,
работа которых зависит от окружения (например, "setlocale" и другие).


Ядро: NoSQL
---------------------------------------------------------------------

Все данные хранятся в виде PHP-кода.
Возможно, самое быстрое хранилище после "хранилища в ОЗУ".
После организации диска в ОЗУ можно увеличить производительность
в 3-5 раз (подробнее в разделе "Улучшение производительности").
Каждый подкаталог хранилища будет инициализироваться лишь по требованию.

Любой экземпляр класса и другие NoSQL-данные могут быть описаны
в текстовом формате в файле типа ".data", подобном YAML, однако
имеющем более строгие правила, такие как "каждая строка может
содержать только одну фразу вида "ключ: значение".

Это удобно для контроля изменений в коде: любое изменение одного
ключа или значения будет выделяться в "git diff" только одной строкой.
Также такой формат существенно ускоряет парсинг файлов.

Ниже приведён пример "*.data"-файла:

    demo
      object_1|class_name
        property_1: value 1
        property_2: value 2 …
        property_N: value N
      array_1
      - item_1: value 1
      - item_2: value 2 …
      - item_N: value N

При этом и объекты (экземпляры классов-паттернов), и массивы могут иметь
любые уровни вложенности и содержать в себе любые другие объекты или
массивы.

После парсинга "*.data"-файлов результат преобразуется
в PHP-код (единое дерево объектов — экземпляров классов-паттернов),
после чего сохраняется в файлы "dynamic/cache/cache-*.php"
раздельно для каждого вида сущности, как показано в примере ниже:
- dynamic/cache/data--blocks.php
- dynamic/cache/data--breadcrumbs.php
- dynamic/cache/data--file_types.php
и так далее.

Описанный выше пример будет преобразован в PHP-файл следующего вида:

    namespace effcore {
      cache::$data['demo'] = new \stdClass;
      cache::$data['demo']->object_1 = new class_name;
      cache::$data['demo']->object_1->property_1 = 'value 1';
      cache::$data['demo']->object_1->property_2 = 'value 2';
      cache::$data['demo']->object_1->property_N = 'value N';
      cache::$data['demo']->array_1['item_1'] = 'value 1';
      cache::$data['demo']->array_1['item_2'] = 'value 2';
      cache::$data['demo']->array_1['item_N'] = 'value N';
    }

Такая архитектура позволяет получать доступ к NoSQL-данным настолько быстро,
насколько это возможно. При использовании PHP-модуля OPCache скорость доступа
может возрасти от 2 до 3 раз. По сути, для доступа к NoSQL-данным системе
достаточно загрузить PHP-файл определённой сущности, и данные станут
доступны сразу же после загрузки.

Таким образом, ядро системы составляет вышеупомянутый набор классов-паттернов
и NoSQL-хранилище, кэш которого представлен в виде PHP-кода,
содержащего экземпляры этих классов в древовидной форме с любым уровнем
вложенности и неограниченных по своей структуре.

Изменять структуру NoSQL-данных можно только через специальный механизм.
Например, системное меню расположено в NoSQL-хранилище, и никто не может
нарушить его работу. Меню анонимного пользователя хранится в SQL-хранилище,
и администратор может редактировать данное меню через
интерфейс системы.

Поддерживаются типы полей:
- integer;
- float;
- boolean;
- string;
- array;
- object|class_name;
- null.


Ядро: SQL
---------------------------------------------------------------------

В качестве SQL-хранилища могут быть использованы MySQL и SQLite.
Требуемые версии можно узнать в файле "readme/software.md".
Подключение к хранилищу и выборка данных осуществляется исключительно по требованию.
Отказ в доступе к SQL-хранилищу не приведёт к выдаче ошибки, а лишь сделает
недоступными некоторые возможности (например, отключатся сессии и вход в
систему, а на страницах с выборками будет показано "0 результатов").

Поддерживаются:
- проверки (checks);
- препарированные запросы (нет шансов для SQL-инъекций);
- транзакции (begin, roll_back, commit);
- сравнения (nocase, binary);
- ограничения (primary, unique, foreign с каскадным действием);
- простые и уникальные индексы (index, unique index);
- подключение к удалённым хранилищам через процесс ручной инициализации;
- префиксы таблиц.

Поддержка каскадных действий внешнего ключа:
- на обновление: "cascade" (не протестированная возможность: "restrict", "no action");
- на   удаление: "cascade" (не протестированная возможность: "restrict", "no action").

Поддерживаются кросс-платформенные типы полей:
- autoincrement;
- varchar;
- integer;
- real;
- time;
- date;
- datetime;
- boolean (как integer: 0|1);
- blob.

Другие типы допускаются, но не протестированы.
Список протестированных типов достаточен для большинства задач.
Рекомендуется использовать только протестированные типы
для обеспечения кросс-платформенной совместимости.
Распределённые запросы к удалённым хранилищам не поддерживаются.

Основной упор сделан на ANSI SQL.
В процессе разработки был исключён PostgreSQL как СУРБД в веб-среде,
наименее соответствующая ANSI-стандартам.

Было принято решение не использовать поле типа timestamp.
Вместо него рекомендуется использовать поле типа datetime.
Данное поле имеет больший диапазон допустимых значений (от "0001-01-01"
до "9999-12-31"), а также не зависит от часового пояса.
При добавлении данных на сервер даты следует
преобразовывать к часовому поясу UTC±0:00.
Вместо оригинального типа timestamp рекомендуется
использовать тип integer.


Ядро: схема
---------------------------------------------------------------------


    ┌────────────────── classes ──────────────────┐             ┌────────────── noSQL data ──────────────┐
    │                                             │             │                                        │
    │  ╔═══════════════════════════════════════╗  │             │   ╔════════════════════════════════╗   │
    │  ║ /module_X/backend/pattern-class_1.php ║  │             │   ║ /module_X/data/instance_1.data ║   │
    │  ╠═══════════════════════════════════════╣  │             │   ╠════════════════════════════════╣   │
    │  ║ /module_X/backend/pattern-class_2.php ║  │             │   ║ /module_X/data/instance_2.data ║   │
    │  ╚═══════════════════════════════════════╝  │             │   ╚════════════════════════════════╝   │
    │                      …                      │             │                    …                   │
    │  ╔═══════════════════════════════════════╗  │    ┌───┐    │   ╔════════════════════════════════╗   │
    │  ║ /module_X/backend/pattern-class_N.php ║──────▶│ + │◀───────║ /module_X/data/instance_N.data ║   │
    │  ╚═══════════════════════════════════════╝  │    └───┘    │   ╚════════════════════════════════╝   │
    │                                             │      │      │                                        │
    └─────────────────────────────────────────────┘      │      └────────────────────────────────────────┘
                                                         │
                                                         │
           ╔══════ big tree (memory) ═════╗              │
           ║                              ║              │
           ║  data[class_instance_1] = {  ║              │
           ║    property_1: value_1       ║              │
           ║    property_2: value_2 …     ║              │
           ║    property_N: value_N }     ║              │
           ║                              ║              │
           ║  data[class_instance_2] = {  ║              │
           ║    property_1: value_1       ║              │
           ║    property_2: value_2 …     ║◀─────────────┘
           ║    property_N: value_N }     ║
           ║  …                           ║
           ║  data[class_instance_N] = {  ║
           ║    property_1: value_1       ║
           ║    property_2: value_2 …     ║
           ║    property_N: value_N }     ║
           ║                              ║
           ╚══════════════════════════════╝
                           │
                           ▼
    ╔════════════ /dynamic/cache/*.php ═══════════╗
    ║                                             ║
    ║   cache[instance_1] = new class             ║
    ║   cache[instance_1]->property_1 = value_1   ║
    ║   cache[instance_1]->property_2 = value_2 … ║
    ║   cache[instance_1]->property_N = value_N   ║
    ║                                             ║
    ║   cache[instance_2] = new class             ║
    ║   cache[instance_2]->property_1 = value_1   ║
    ║   cache[instance_2]->property_2 = value_2 … ║
    ║   cache[instance_2]->property_N = value_N   ║
    ║   …                                         ║
    ║   cache[instance_N] = new class             ║
    ║   cache[instance_N]->property_1 = value_1   ║
    ║   cache[instance_N]->property_2 = value_2 … ║
    ║   cache[instance_N]->property_N = value_N   ║
    ║                                             ║
    ╚═════════════════════════════════════════════╝


CSS, JS, SASS, LESS
---------------------------------------------------------------------

Единая точка входа (single entry point) даёт возможность системе
контролировать процесс выдачи содержимого любого файла, благодаря чему
стало возможным использование внешних переменных в CSS и JS-файлах.
Такие переменные начинаются с "%%_", а содержащие их файлы имеют
расширения "cssd" и "jsd".

Проект не реализует и считает технологию потокового сжатия CSS и JS устаревшей.
Следует заметить, что разработчики "Google PageSpeed Insights" считают иначе.
Недостатки потокового сжатия:
- сжатию подвергаются текстовые файлы в объёме от 1 до 10 КиБ,
  что при современной скорости передачи данных не существенно,
  при этом на сжатие затрачиваются ресурсы веб-сервера,
  а на распаковку — клиента (что в итоге сказывается и на заряде
  батарей мобильных клиентов);
- для CSS объём файла выше 10 КиБ считается следствием неправильного
  каскадирования стилей и/или использования такой пагубной технологии
  как SASS или LESS, потворствующей "бракокодированию";
- JS-файлы могут быть изначально сжаты и обфусцированы путём редукционной
  реорганизации JS-кода сторонними программами или сервисами.
Однако никто не мешает использовать возможности потокового сжатия
непосредственно веб-сервера.


Событийная модель
---------------------------------------------------------------------

Событийная модель построена достаточно прозрачно и предсказуемо.
Достаточно зарегистрировать новое событие в "events.data" своего модуля,
указать его вес и обработчик в PHP-коде, сбросить кэш, и событие
начнёт обрабатываться. На странице "NoSQL данные → События" можно
просмотреть все зарегистрированные в системе события (данный раздел
станет доступен после включения модуля "Разработка").


Веб-сервер
---------------------------------------------------------------------

В качестве веб-сервера поддерживаются Apache, NGINX, IIS.
Требуемые версии можно узнать в файле "readme/software.md".


Кэширование
---------------------------------------------------------------------

Благодаря своей архитектуре проекты среднего уровня не требуют кэширования.
Для больших проектов кэширование обычно выполняется сторонними средствами
веб-сервера, что изначально предполагается автором.


Оформление
---------------------------------------------------------------------

Для оформления сайта/портала в системе имеется одноимённый раздел "Вид".
В этом разделе администратор может изменять цветовую схему элементов страницы.
Количество цветов ограничено полным набором именованных CSS-цветов (например, "black",
"white" и так далее). Также в этом разделе присутствуют цветовые предустановки и "в один
клик" администратор может изменить оформление всех доступных элементов (например,
активировать светлую тему оформления). Здесь же присутствует список имеющихся
в системе макетов.

Система оперирует лишь одним типом коллекций файлов — это модули.
Здесь нет привычных многим тем оформления.
Для создания профиля оформления смотрите раздел "Развёртывание".


Развёртывание
---------------------------------------------------------------------

Вносить изменения в файлы системы является плохой идеей, потому что все они
будут потеряны после обновления системы.

Хорошим решением является создание в директории "modules" нового модуля
с профилем собственных настроек. Пример такого модуля можно
позаимствовать из раздела "Профили" (достаточно скопировать один из профилей
и поместить его в директорию "modules", после чего внести свои изменения и
сбросить кэш).

В таком модуле можно задать свои собственные:
- цвета;
- цветовые предустановки;
- статические файлы каскадных стилей "*.css";
- статические файлы JavaScript "*.js";
- динамические файлы каскадных стилей "*.cssd";
- динамические файлы JavaScript "*.jsd";
- шаблоны;
- макеты;
- изображения;
- favicons;
и другое.

Также в таком модуле можно будет применить механизм "Changes".
Данный механизм даёт возможность вносить изменения в работу системы.
Его пример показан в файле "demo--data--changes.data" модуля "Демо".
Механизм "Changes" изменяет глобальное NoSQL-дерево, которое
после очистки кэша будет преобразовано системой в PHP-код.

После создания собственного модуля с нужными настройками процесс
развёртывания будет выглядеть предельно просто — достаточно установить
систему и включить этот модуль.


Локализация
---------------------------------------------------------------------

В системе уже имеются переводы её интерфейса на Белорусский и Русский языки.
Предполагается, что для каждой языковой версии сайта/портала
администратор организует свой собственный поддомен.
Во многих случаях разные языковые версии сайта/портала имеют отличия
не только в содержании, но и в структуре. Например, главное меню на одной
языковой версии может иметь одни пункты меню, а на другой — совсем иные,
при этом будут отличаться и названия самих пунктов и их адреса и количество
этих пунктов. Именно поэтому было принято решение не усложнять систему
и не вводить во многих аспектах бесполезный функционал.

Если же какая либо страница будет иметь язык отличный от всего сайта, то
этот язык можно будет указать при создании/редактировании такой страницы.
При этом администратор должен контролировать язык контента, который появится
на данной странице.

Система использует более совершенную систему "Plural".
С помощью регулярных выражений можно описать практически любую
зависимость части слова от присутствующих во фразе числовых
и не числовых аргументов.


Улучшение производительности
---------------------------------------------------------------------

Рекомендуется включить PHP OPCache.
Рекомендуется использовать SSD (твердотельные накопители).
Во многих случаях директорию "dynamic/cache" можно организовать в ОЗУ.
Для повышения уровня надёжности сервера такая ОЗУ должна поддерживать
ECC (error-correcting code), а сам сервер — работать совместно с
ИБП (источником бесперебойного питания).


Лицензирование
---------------------------------------------------------------------

Система является открытой и бесплатной.
Система не является общественным достоянием.
Любой желающий на её основе может создать сайт, портал или
сервис как себе лично, так и любому заказчику.
Однако нельзя распространять файлы системы в исходном или
изменённом виде, или совместно с чем-либо ещё.
Это ограничение не распространяется на сторонние модули,
авторы которых сами определяют лицензионную политику.

