

Общая информация
---------------------------------------------------------------------

- Тип: система управления содержимым/фреймворк
- Автор: Рысевец Максим Владимирович
- Разработчик: Рысевец Максим Владимирович
- Начало разработки: конец 2016 года
- Первый выпуск: 01.06.2021
- Написан на: PHP
- Поддерживаемые ОС: UNIX, Linux, Microsoft Windows
- Поддерживаемые веб-сервера: NGINX, Apache, IIS
- Поддерживаемые БД: SQLite, MySQL
- Проект с открытым исходным кодом: да
- Лицензия: проприетарное программное обеспечение
- Сайт: http://effcore.com

EFFCORE — это мини-CMS (система управления содержимым)
и мини-CMF (фреймворк управления содержимым) нового поколения,
разработанная в промежутке между 2016 и 2021 годам.
Использует такие технологии как: HTML5, CSS3, IP v6, SVG, SMIL,
UTF8, UTC, WAI-ARIA, NoSQL, Markdown, UML, PSR-0.

Может использоваться в качестве инструмента для построения
сайтов простыми пользователями, а также в качестве инструмента для
разработки сайтов, порталов и сервисов профессиональными веб-разработчиками.

Название системы является акронимом и происходит от фразы "effective core".
Система была разработана с нуля. Её главный принцип — полное отсутствие
стороннего кода (для исключения правовых претензий и любых других ограничений,
связанных с заимствованием), а также полное отсутствие сторонних идей (для
поиска инновационных решений).

Стимулом для создания системы послужила массовая деградация в развитии
Open Source проектов. Если рассмотреть данную ситуацию, то можно увидеть,
что разработчиками таких проектов являются люди разного уровня подготовки,
расположенные в разных частях планеты. Несогласованность в их действиях, а
также разные взгляды на решения в проекте являются лишь частью проблемы.
Второй существенный недостаток — это экстенсивный путь развития кода таких
проектов в противовес интенсивному, то есть вместо того, чтобы создавать
собственный код, они, как правило, берут очередную библиотеку, которая была
написана непонятно кем, непонятно где и непонятно для чего и пытаются
совместить её с группой таких же библиотек, которые никак не согласованы
между собой и имеют избыточный и не до конца протестированный функционал.
В результате получается набор непонятных и не согласованных библиотек,
которые имеют плохо протестированный и избыточный функционал, который в
свою очередь постоянно растёт в объёме. К сожалению, многие разработчики
"погрязли" в таком коде и пытаются отрицать очевидные вещи.

Основной упор в системе сделан на получение максимальной производительности.
Оценочным критерием является простое и понятное условие: система,
установленная на хостинге с самым дешёвым тарифным планом, который
соответствует минимальным требованиям установки (от ~3-5$ в месяц),
должна генерировать главную страницу за время 0,005 секунды если OPCache
включен или 0,05 секунды если OPCache выключен, что в первом случае
позволяет обслуживать до ~200 клиентов в секунду, а во втором случае
позволяет обслуживать до ~20 клиентов в секунду (исключая учёт
параллельной загрузки файлов).


Управление содержимым
---------------------------------------------------------------------

В системе пользователю доступен набор макетов. Каждый макет имеет определённое
количество регионов. В каждый регион могут помещаться блоки с текстом, меню,
формы (только в регионе "content") и другие. Каждая страница может иметь
индивидуальный макет. Таким образом, разметка любой страницы может быть
уникальной.


Обновление
---------------------------------------------------------------------

Обновление системы предоставляет:

- новый функционал;
- исправления ошибок;
- улучшение производительности;
- улучшение безопасности.

Для обновления системы в ручном режиме необходимо зайти на её официальный
сайт effcore.com и загрузить последний дистрибутив в виде архива.
Далее следует распаковать загруженный архив локально.
Важно: среди распакованных файлов вы найдёте полупустые директории "modules" и "dynamic"
которые необходимо удалить до процесса копирования на веб-сервер!
Удалять их нужно потому, что в некоторых операционных системах при копировании
директорий происходит полная замена старых директорий на новые, а не их слияние,
что приведёт к утрате данных на веб-сервере.
Далее следует скопировать оставшиеся файлы на веб-сервер таким образом чтобы
новые файлы из дистрибутивы заменили старые файлы на веб-сервере.
После этого в административном интерфейсе системы следует посетить раздел
"Управление → Модули → Обновить → Данные" и выполнить обновление для каждого
модуля если это потребуется.

Для обновления системы через Git-репозиторий необходимо в административном интерфейсе
системы зайти в раздел "Управление → Модули → Обновить → Файлы из репозитория" и
выполнить обновление в одно нажатие кнопкой "обновить".
Если кнопка "обновить" недоступна, но доступна кнопка "восстановить репозиторий",
то сначала необходимо выполнить процедуру восстановления репозитория.
Если недоступны кнопки "обновить" и "восстановить репозиторий" значит указанный
модуль не имеет собственного репозитория и его обновление через Git невозможно.

Процесс обновления через Git-репозиторий также можно выполнить из терминала/консоли/шелла
если зайти на веб-сервер через SSH соединение и перейти в директорию "shell" после чего
запустить скрипт "./update.sh". Такое обновление возможно только в случае, если в веб-корне
имеется директория ".git".


Безопасность
---------------------------------------------------------------------

Немаловажным фактором в системе является безопасность.

Были рассмотрены следующие векторы атак:

- Злоумышленник может попытаться получить доступ к данным SQLite, ключам системы.
- Злоумышленник может попытаться получить доступ к таким файлам как ".htaccess", ".nginx",
  "web.config", директории "/.git/", "/dynamic/tmp/.git_restore-system/" и другим подобным.
- Злоумышленник может попытаться найти слабое место в директивах в файле настроек
  веб-сервера (".htaccess", ".nginx", "web.config") если директив много и/или они составлены
  некорректно и/или не учитывают все возможные ситуации и/или после обновления
  программного обеспечения изменились правила оформления директив в таких файлах.
- Злоумышленник может попытаться получить доступ к файлам вне пределов корневой веб-директории
  манипулируя такими комбинациями как "./", "../", "~/", "//" и другими.
- Злоумышленник может попытаться ввести в поля формы данные для SQL-инъекции.
- Злоумышленник может попытаться подделать идентификатор сессии.
- Злоумышленник может попытаться многократно послать предварительно заполненную
  форму (форму аутентификации "form_login", форму регистрации нового пользователя "form_registration",
  форму восстановления пароля "form_recovery") с целью подбора адреса электронной почты и/или
  имени пользователя и/или пароля или обхода CAPTCHA.
- Злоумышленник может попытаться разблокировать в форме заблокированные поля средствами браузера.
- Злоумышленник может попытаться послать большее значение поля чем разрешено атрибутами
  "maxlength", "max", "step", "min", "max" и другими.
- Злоумышленник может попытаться осуществить GET/POST-запросы с символами, которые
  недопустимы стандартами RFC.
- Злоумышленник может попытаться осуществить GET/POST-запросы в которых размерность
  передаваемых массивов или их индексы могут не соответствовать допустимым.
- Злоумышленник может попытаться подставить ошибочные аргументы
  в запросе URL (http://domain/path?QUERY).
- Злоумышленник может попытаться внести в поля формы вредоносный код (JavaScript).
- Злоумышленник может попытаться загрузить изображение с вредоносным содержимым.
- Злоумышленник может попытаться получить доступ к профилю пользователя
  имея временный доступ к его рабочему месту.


Решения для обеспечения безопасности
---------------------------------------------------------------------

Файловый вектор:

- Файлы настроек веб-сервера (".htaccess", ".nginx", "web.config") содержат директивы,
  запрещающие доступ пользовательского агента к директориям "/dynamic/cache/",
  "/dynamic/data/", "/dynamic/logs/". Злоумышленник не сможет получить доступ
  к данным SQLite, ключам системы.
- Файлы настроек веб-сервера (".htaccess", ".nginx", "web.config") содержат директиву,
  запрещающую доступ пользовательского агента к любым файлам или директориям, чьё имя
  начинается с символа "." на любом уровне вложенности. Злоумышленник не сможет получить
  доступ к таким файлам как ".htaccess", ".nginx", директории "/.git/",
  "/dynamic/tmp/.git_restore-system/" и другим подобным.
- Файлы настроек веб-сервера (".htaccess", ".nginx", "web.config") содержат директиву,
  запрещающую доступ пользовательского агента к файлу "web.config" на любом уровне
  вложенности. Злоумышленник не сможет получить доступ к файлу "web.config".
- Файлы настроек веб-сервера (".htaccess", ".nginx", "web.config") содержат директиву,
  обеспечивающую единую точку входа в файл "index.php", что гарантирует единый
  и не противоречивый подход к защите любого файла системы.
- Дополнительно, на уровне PHP, системой обеспечивается ограничение доступа пользовательского
  агента к файловой системе веб-сервера вне пределов корневой веб-директории.
- Дополнительно, на уровне PHP, системой обеспечивается фильтрация в запросах URL, в которых
  содержатся такие комбинации как "./", "../", "~/", "//".
- Дополнительно, на уровне PHP, системой обеспечивается доступа пользовательского агента
  только к реально существующему файлу (кроме типа "kind: virtual").
  При этом PHP-скрипт должен иметь право на чтение запрашиваемого файла.
- На уровне PHP системой ограничивается доступ к файлам, тип которых задан
  как "protected" ("kind: protected").
- На уровне PHP системой могут быть организованы дополнительные ограничения
  на доступ к любому типу файла (по требованию разработчика через обработчик
  события "on_load").

Вектор БД:

- Перед выполнением любого SQL-запроса производится его подготовка (препарация),
  что исключает возможность SQL-инъекций.

Сессионный вектор:

- Идентификатор сессии "session_id" подписываются ключом "settings/core/keys/session",
  расположенным на стороне веб-сервера, что делает его подделку невозможной.
- Идентификатор сессии может содержать наименование пользовательского агента и
  его IP-адрес (при аутентификации пользователь сам определяет, следует ли
  осуществлять привязку его сессии к его IP-адресу), что делает перехват
  идентификатора сессии бессмысленной процедурой — запрос злоумышленника
  с другого IP-адреса будет проигнорирован.
- Идентификатор сессии может иметь кратковременный период действия (при
  аутентификации пользователь сам определяет является ли его сессия
  кратковременной или нет).
- Идентификатор сессии по умолчанию не является кросс-доменным, т.е.
  не передаётся на домены третьих сторон.

Вектор HTTP-запроса:

- Валидационный идентификатор формы "validation_id" подписываются ключом
  "settings/core/keys/form_validation", расположенным на стороне веб-сервера,
  что делает его подделку невозможной.
- Валидационный идентификатор формы содержит наименование пользовательского агента и
  его IP-адрес, что делает перехват идентификатора бессмысленной процедурой — запрос
  злоумышленника с другого IP-адреса будет проигнорирован.
  Время жизни валидационного идентификатора ограничено по времени.
- Процесс проверки (валидации) данных производится на стороне веб-сервера и попытка
  их подделки на стороне клиента бессмысленна (например, попытка разблокировать в форме
  заблокированные поля или попытка внести в поля недопустимые данные).
- Данные GET/POST-запроса проходят проверку на соответствие стандартам RFC
  и попытка вызвать URL с недопустимыми символами будет обработана корректно.
- Данные GET/POST-запроса проходят проверку на соответствие размерностей массивов и их индексов.
- Аргументы запроса URL (http://domain/path?QUERY) проходят фильтрацию.
- Базовый модуль CAPTCHA позволяет минимизировать возможность перебора адреса
  электронной почты и пароля в форме аутентификации "form_login",
  перебора адреса электронной почты и/или имени пользователя в форме регистрации нового
  пользователя "form_registration", перебора адреса электронной почты в форме
  восстановления доступа "form_recovery", а также регистрации спам-роботов в форме
  регистрации нового пользователя "form_registration".
- Фильтрация вводимых данных не позволяет внести в систему вредоносный код (JavaScript).
- Фильтрация выводимых данных не позволяет отобразить вредоносный код (JavaScript).
- Фильтрация изображений исключает возможность показа пользователям изображения
  с вредоносным содержимым.

Организационный вектор:

- Система разрешений и ролей производит выдачу расширенных прав только авторизованным лицам.
- Доступ к профилям других пользователей имеют только администраторы (например,
  пользователи с ролью "Администраторы").
- Все адреса электронной почты пользователей являются скрытыми от
  других участников системы и вычислить соответствие между именем пользователя
  и его адресом электронной почты не представляется возможным.
  Таким образом удалённо сбросить пароль другого пользователя или попытаться
  подобрать пароль к его аккаунту будет невозможно.
- Внести изменения в регистрационные данные пользователя можно только
  в случае если известен пароль от его аккаунта — это минимизирует
  внутрисистемную угрозу (угрозу безопасности со стороны персонала).

Функциональный вектор:

- Осуществлена возможность работы без JavaScript.
- Осуществлена возможность получения "Хэша последовательности" и "Хэша данных" в консоли системы.
- Детерминизм в работе системы — при одних и тех же входных параметрах выдаётся
  один и тот же результат вне зависимости от платформы, и как результат — полный отказ
  от функций, работа которых зависит от окружения (например, "setlocale" и другие).
- Использование в коде оператора тождественного равенства '===' вместо простого
  равенства '==', в результате чего исключается опасная ситуация
  вида: $var = 0; ($var == 'some_text') === true;
- В коде в циклах "foreach" исключение ссылок на переменные "ключ" и/или "значение"
  с последующей модификацией структуры массива с использованием этих переменных,
  что могло приводить к перекосу структуры массива и разрушению отношения
  "ключ + значение": foreach ($array as $key => &$value) if ($some) unset($value);


Локализация
---------------------------------------------------------------------

В системе уже имеются переводы её интерфейса на Белорусский и Русский языки.
В административном интерфейсе системы в разделе "Управление → Локализации" можно
задать основной язык интерфейса системы, а в разделе
"Управление → Данные → Содержимое → Страницы" для каждой страницы можно
задать собственный язык.

Организовать мультиязычный веб-сайт/веб-портал можно двумя способами:

1) в рамках одного домена организовать столько копий страниц, меню, текстовых блоков и т.д.
   сколько языков требуется поддерживать;
2) для каждого языкового домена организовать собственную языковую копию системы.

И первая и вторая версия предполагают наличие дубликатов страниц, меню, текстовых
блоков и другого контента на различных языках. Данный подход является оправданным т.к.
практически всегда разные языковые версии имеют отличия не только в содержании,
но и в структуре. Например, главное меню на одной языковой версии может иметь одни пункты меню,
а на другой — совсем иные, при этом будут отличаться и названия самих пунктов и их адреса и
количество этих пунктов.

В модуле под названием "Профиль "Классика" вы можете увидеть пример реализации
мультиязычности по способу №1.

Система использует более совершенную систему "Plural". С помощью регулярных выражений
можно описать практически любую зависимость части слова от присутствующих во фразе числовых
и не числовых аргументов.


Профили/Развёртывание
---------------------------------------------------------------------

В системе не существует привычных нам тем оформления. Для создания своего уникального
вида существует такой тип модуля как "Профиль" ("module_as_profile"). В профиле могут
быть описаны: страницы, меню, любые виды блоков (например, содержащие текст, аудио, видео,
галереи, выборки, опросы), цвета и их наборы, стили в виде файлов "*.css"/"*.cssd",
скрипты в виде файлов "*.js"/"*.jsd", макеты страниц, шаблоны элементов, любые виды файлов,
которые необходимо скопировать в систему при развёртывании профиля (изображения, аудио, видео,
"robots.txt", "sitemap.xml" и другие) и всё, что может реализовать любой типичный модуль.

Все модули и профили необходимо размещать в директории "modules" иначе при обновлении они
будут потеряны — система Git очистит все директории до состояния эталонной копии.
По этой же причине нельзя вносить изменения в модули и профили, которые располагаются
в директории "system". В директории "profiles/examples" находятся примеры профилей,
которые вы можете скопировать в директорию "modules" и производить с ними любые действия,
не боясь потери данных (рекомендуется переименовать все названия внутри профиля на свои
собственные). При копировании модулей в административном интерфейсе системы
в разделе "Управление → Модули → Установить" следует сбросить кэш (кнопка "↺") для того,
чтобы новые модули появились здесь же — в списке доступных модулей.

Для внедрения любой сторонней библиотеки на базе PHP или JS необходимо расположить
её файлы в обёртке пустого модуля и включить данный модуль после чего все файлы библиотеки
станут доступны.

Создав профиль, вы сможете производить развёртывание системы со своими настройками очень
просто — достаточно будет включить этот профиль в установленной системе (как и любой другой
модуль), или же на странице установки системы (если установка производится с нуля) просто
выбрать свой профиль из списка доступных.


Улучшение производительности
---------------------------------------------------------------------

Для повышения производительности следует:

- включить PHP OPCache;
- перейти на использование PHP v.8+;
- перейти на использование твердотельных накопителей (англ. Solid-State Drive, SSD);
- перенести директории "dynamic/cache" и "dynamic/tmp" в ОЗУ при этом
  для повышения уровня надёжности веб-сервера такая ОЗУ должна поддерживать
  коррекцию ошибок (англ. error-correcting code, ECC), а сам сервер использовать
  источник бесперебойного питания (англ. Uninterruptible Power Supply, UPS).


Лицензирование
---------------------------------------------------------------------

Система является открытой и бесплатной.
Система не является общественным достоянием.
Любое физическое лицо либо организация может создать на основе данной системы
веб-сайт/веб-портал/веб-сервис себе лично либо третьей стороне.
Однако запрещено распространять файлы данной системы в исходном или
изменённом виде, или совместно с чем-либо ещё.
Это ограничение не распространяется на модули других разработчиков,
авторы которых сами определяют свою лицензионную политику.


Архитектура
---------------------------------------------------------------------

Архитектура выполнена по классической схеме MVC.
Является гибридной системой на базе NoSQL и SQL-хранилищ.
NoSQL-хранилище имеет уникальную реализацию и представляет собой гибрид из
документ-ориентированной, объектно-ориентированной и иерархической модели.

Код системы адаптирован под повторное использование.
Система состоит из множества маленьких классов/классов-паттернов,
которые содержат в себе в среднем от 3 до 15 методов, которые, в свою очередь,
состоят из 3-15 строк кода. Восприятие кода существенно облегчается благодаря
"матричному" стилю вёрстки (в некоторых местах напоминает синтаксис Python).
Всё, что казалось сложным, было отвергнуто или переделано.
Каждая функция итеративно совершенствовалась от 3 до 10 раз.
Функциональное тестирование выполнялось на всём множестве
комбинаторных перестановок.

В состав системы входит страница с UML-диаграммой всех классов
и ссылкой для загрузки JSON-файла с описанием классов в формате
программы StarUML.


Файловая организация
---------------------------------------------------------------------

Грамотное расположение файлов в системе позволяет определить их назначение,
не прибегая к документации.

В директориях вида "module_*/frontend" располагается всё необходимое для frontend-разработки.
В директориях вида "module_*/backend" располагается всё необходимое для backend-разработки.
В директориях вида "module_*/data" располагаются NoSQL-данные.

Фактически, работа файлов не зависит от их расположения и
при необходимости они всё равно будут найдены и обработаны.
Расположение файлов в определённых директориях — это лишь организационная
мера, призванная облегчить работу с системой.

Помещать дополнительные модули/библиотеки следует в директорию "modules" для того,
чтобы после обновления системы через интерфейс администратора они не были очищены
системой Git.

Система имеет встроенный парсер и загрузчик классов PSR-0.
Для добавления новой библиотеки (набора классов) достаточно поместить
её файлы на веб-сервер и сбросить кэш, после этого они становятся доступными
из любого места системы.


Ядро: NoSQL
---------------------------------------------------------------------

Все данные хранятся в виде PHP-кода.
Возможно, самое быстрое хранилище после "хранилища в ОЗУ".
Каждый подкаталог хранилища будет инициализироваться лишь по требованию.

Любой экземпляр класса и другие NoSQL-данные могут быть описаны
в текстовом формате в файле типа ".data", подобном YAML, однако
имеющем более строгие правила, такие как "каждая строка может
содержать только одну фразу вида "ключ: значение".

Это удобно для контроля изменений в коде: любое изменение одного
ключа или значения будет выделяться в "git diff" только одной строкой.
Также такой формат существенно ускоряет парсинг файлов.

Ниже приведён пример "*.data"-файла:

    demo
      object_1|class_name
        property_1: value 1
        property_2: value 2 …
        property_N: value N
      array_1
      - item_1: value 1
      - item_2: value 2 …
      - item_N: value N

При этом и объекты (экземпляры классов-паттернов), и массивы могут иметь
любые уровни вложенности и содержать в себе любые другие объекты или
массивы.

После парсинга "*.data"-файлов результат преобразуется
в PHP-код (единое дерево объектов — экземпляров классов-паттернов),
после чего сохраняется в файлы "dynamic/cache/cache-*.php"
раздельно для каждого вида сущности, как показано в примере ниже:
- dynamic/cache/data--blocks.php
- dynamic/cache/data--breadcrumbs.php
- dynamic/cache/data--file_types.php
и так далее.

Описанный выше пример будет преобразован в PHP-файл следующего вида:

    namespace effcore {
      cache::$data['demo'] = new \stdClass;
      cache::$data['demo']->object_1 = new class_name;
      cache::$data['demo']->object_1->property_1 = 'value 1';
      cache::$data['demo']->object_1->property_2 = 'value 2';
      cache::$data['demo']->object_1->property_N = 'value N';
      cache::$data['demo']->array_1['item_1'] = 'value 1';
      cache::$data['demo']->array_1['item_2'] = 'value 2';
      cache::$data['demo']->array_1['item_N'] = 'value N';
    }

Такая архитектура позволяет получать доступ к NoSQL-данным настолько быстро,
насколько это возможно. При использовании PHP-модуля OPCache скорость доступа
может возрасти от 2 до 3 раз. По сути, для доступа к NoSQL-данным системе
достаточно загрузить PHP-файл определённой сущности, и данные станут
доступны сразу же после загрузки.

Таким образом, ядро системы составляет вышеупомянутый набор классов-паттернов
и NoSQL-хранилище, кэш которого представлен в виде PHP-кода,
содержащего экземпляры этих классов в древовидной форме с любым уровнем
вложенности и неограниченных по своей структуре.

Изменять структуру NoSQL-данных можно только через специальный механизм.
Например, системное меню расположено в NoSQL-хранилище, и никто не может
нарушить его работу. Меню анонимного пользователя хранится в SQL-хранилище,
и администратор может редактировать данное меню через
интерфейс системы.

Поддерживаются типы полей:
- integer;
- float;
- boolean;
- string;
- array;
- object|class_name;
- null.

В системе реализован механизм "Changes". Данный механизм предоставляет возможность вносить
изменения в глобальное NoSQL-дерево на базе которого работает вся система.
Пример внесения изменений показан в файле "demo--data--changes.data" модуля "Демо".
После применения механизма и очистки кэша произойдёт перестройка всего дерева.


Ядро: SQL
---------------------------------------------------------------------

В качестве SQL-хранилища могут быть использованы MySQL и SQLite.
Требуемые версии можно узнать в файле "readme/software.md".
Подключение к хранилищу и выборка данных осуществляется исключительно по требованию.
Отказ в доступе к SQL-хранилищу не приведёт к выдаче ошибки, а лишь сделает
недоступными некоторые возможности (например, отключатся сессии и вход в
систему, а на страницах с выборками будет показано "0 результатов").

Поддерживаются:
- проверки (checks);
- препарированные запросы (нет шансов для SQL-инъекций);
- транзакции (begin, roll_back, commit);
- сравнения (nocase, binary);
- ограничения (primary, unique, foreign с каскадным действием);
- простые и уникальные индексы (index, unique index);
- подключение к удалённым хранилищам через процесс ручной инициализации;
- префиксы таблиц.

Поддержка каскадных действий внешнего ключа:
- на обновление: "cascade" (не протестированная возможность: "restrict", "no action");
- на   удаление: "cascade" (не протестированная возможность: "restrict", "no action").

Поддерживаются кросс-платформенные типы полей:
- autoincrement;
- varchar;
- integer;
- real;
- time;
- date;
- datetime;
- boolean (как integer: 0|1);
- blob.

Другие типы допускаются, но не протестированы.
Список протестированных типов достаточен для большинства задач.
Рекомендуется использовать только протестированные типы
для обеспечения кросс-платформенной совместимости.
Распределённые запросы к удалённым хранилищам не поддерживаются.

Основной упор сделан на ANSI SQL.
В процессе разработки был исключён PostgreSQL как СУРБД в веб-среде,
наименее соответствующая ANSI-стандартам.

Было принято решение не использовать поле типа timestamp.
Вместо него рекомендуется использовать поле типа datetime.
Данное поле имеет больший диапазон допустимых значений (от "0001-01-01"
до "9999-12-31"), а также не зависит от часового пояса.
При добавлении данных на сервер даты следует
преобразовывать к часовому поясу UTC±0:00.
Вместо оригинального типа timestamp рекомендуется
использовать тип integer.


Ядро: схема
---------------------------------------------------------------------


    ┌────────────────── classes ──────────────────┐             ┌────────────── noSQL data ──────────────┐
    │                                             │             │                                        │
    │  ╔═══════════════════════════════════════╗  │             │   ╔════════════════════════════════╗   │
    │  ║ /module_X/backend/pattern-class_1.php ║  │             │   ║ /module_X/data/instance_1.data ║   │
    │  ╠═══════════════════════════════════════╣  │             │   ╠════════════════════════════════╣   │
    │  ║ /module_X/backend/pattern-class_2.php ║  │             │   ║ /module_X/data/instance_2.data ║   │
    │  ╚═══════════════════════════════════════╝  │             │   ╚════════════════════════════════╝   │
    │                      …                      │             │                    …                   │
    │  ╔═══════════════════════════════════════╗  │    ┌───┐    │   ╔════════════════════════════════╗   │
    │  ║ /module_X/backend/pattern-class_N.php ║──────▶│ + │◀───────║ /module_X/data/instance_N.data ║   │
    │  ╚═══════════════════════════════════════╝  │    └───┘    │   ╚════════════════════════════════╝   │
    │                                             │      │      │                                        │
    └─────────────────────────────────────────────┘      │      └────────────────────────────────────────┘
                                                         │
                                                         │
           ╔══════ big tree (memory) ═════╗              │
           ║                              ║              │
           ║  data[class_instance_1] = {  ║              │
           ║    property_1: value_1       ║              │
           ║    property_2: value_2 …     ║              │
           ║    property_N: value_N }     ║              │
           ║                              ║              │
           ║  data[class_instance_2] = {  ║              │
           ║    property_1: value_1       ║              │
           ║    property_2: value_2 …     ║◀─────────────┘
           ║    property_N: value_N }     ║
           ║  …                           ║
           ║  data[class_instance_N] = {  ║
           ║    property_1: value_1       ║
           ║    property_2: value_2 …     ║
           ║    property_N: value_N }     ║
           ║                              ║
           ╚══════════════════════════════╝
                           │
                           ▼
    ╔════════════ /dynamic/cache/*.php ═══════════╗
    ║                                             ║
    ║   cache[instance_1] = new class             ║
    ║   cache[instance_1]->property_1 = value_1   ║
    ║   cache[instance_1]->property_2 = value_2 … ║
    ║   cache[instance_1]->property_N = value_N   ║
    ║                                             ║
    ║   cache[instance_2] = new class             ║
    ║   cache[instance_2]->property_1 = value_1   ║
    ║   cache[instance_2]->property_2 = value_2 … ║
    ║   cache[instance_2]->property_N = value_N   ║
    ║   …                                         ║
    ║   cache[instance_N] = new class             ║
    ║   cache[instance_N]->property_1 = value_1   ║
    ║   cache[instance_N]->property_2 = value_2 … ║
    ║   cache[instance_N]->property_N = value_N   ║
    ║                                             ║
    ╚═════════════════════════════════════════════╝


CSS, JS, SASS, LESS
---------------------------------------------------------------------

Единая точка входа (single entry point) даёт возможность системе
контролировать процесс выдачи содержимого любого файла, благодаря чему
стало возможным использование внешних переменных в CSS и JS-файлах.
Такие переменные начинаются с "%%_", а содержащие их файлы имеют
расширения "cssd" и "jsd".

Проект не реализует и считает технологию потокового сжатия CSS и JS устаревшей.
Следует заметить, что разработчики "Google PageSpeed Insights" считают иначе.
Недостатки потокового сжатия:
- сжатию подвергаются текстовые файлы в объёме от 1 до 10 КиБ,
  что при современной скорости передачи данных не существенно,
  при этом на сжатие затрачиваются ресурсы веб-сервера,
  а на распаковку — клиента (что в итоге сказывается и на заряде
  батарей мобильных клиентов);
- для CSS объём файла выше 10 КиБ считается следствием неправильного
  каскадирования стилей и/или использования такой пагубной технологии
  как SASS или LESS, потворствующей "бракокодированию";
- JS-файлы могут быть изначально сжаты и обфусцированы путём редукционной
  реорганизации JS-кода сторонними программами или сервисами.
Однако никто не мешает использовать возможности потокового сжатия
непосредственно веб-сервера.


Событийная модель
---------------------------------------------------------------------

Событийная модель построена достаточно прозрачно и предсказуемо.
Достаточно зарегистрировать новое событие в "events.data" своего модуля,
указать его вес и обработчик в PHP-коде, сбросить кэш, и событие
начнёт обрабатываться. На странице "NoSQL данные → События" можно
просмотреть все зарегистрированные в системе события (данный раздел
станет доступен после включения модуля "Разработка").


Кэширование
---------------------------------------------------------------------

Благодаря своей архитектуре проекты среднего уровня не требуют кэширования.
Для больших проектов кэширование обычно выполняется сторонними средствами
веб-сервера, что изначально предполагается автором.


Оформление
---------------------------------------------------------------------

Для оформления сайта/портала в системе имеется одноимённый раздел "Вид".
В этом разделе администратор может изменять цветовую схему элементов страницы.
Количество цветов ограничено встроенной палитрой.
Дополнительные цвета можно добавить через создание нового профиля.
Также в этом разделе присутствуют цветовые предустановки и "в один
клик" администратор может изменить оформление всех доступных элементов (например,
активировать светлую тему оформления). Здесь же присутствует список имеющихся
в системе макетов.

