

Общая информация
---------------------------------------------------------------------

- Тип: система управления содержимым/фреймворк
- Автор: Рысевец Максим Владимирович
- Разработчик: Рысевец Максим Владимирович
- Начало разработки: конец 2016 года
- Первый выпуск: 01.01.2022
- Написан на: PHP
- Поддерживаемые ОС: UNIX, Linux, Microsoft Windows
- Поддерживаемые веб-сервера: NGINX, Apache, IIS
- Поддерживаемые БД: SQLite, MySQL
- Проект с открытым исходным кодом: да
- Лицензия: проприетарное программное обеспечение
- Сайт: http://effcore.com
- Репозиторий: http://bitbucket.org/effcore/core

EFFCORE — это мини-CMS (система управления содержимым)
и мини-CMF (фреймворк управления содержимым) нового поколения,
разработанная в промежутке между 2016 и 2022 годам.
Использует такие технологии как: HTML5, CSS3, IP v6, SVG, SMIL,
UTF8, UTC, WAI-ARIA, NoSQL, Markdown, UML, PSR-0.

Может использоваться в качестве инструмента для построения
сайтов простыми пользователями, а также в качестве инструмента для
разработки сайтов, порталов и сервисов профессиональными веб-разработчиками.

Название системы является акронимом и происходит от фразы "effective core".
Система была разработана с нуля. Её главный принцип — полное отсутствие
стороннего кода (для исключения правовых претензий и любых других ограничений,
связанных с заимствованием), а также полное отсутствие сторонних идей (для
поиска инновационных решений).

Стимулом для создания системы послужила массовая деградация в развитии
Open Source проектов. Если рассмотреть данную ситуацию, то можно увидеть,
что разработчиками таких проектов являются люди разного уровня подготовки,
расположенные в разных частях планеты. Несогласованность в их действиях, а
также разные взгляды на решения в проекте являются лишь частью проблемы.
Второй существенный недостаток — это экстенсивный путь развития кода таких
проектов в противовес интенсивному, то есть вместо того, чтобы создавать
собственный код, они, как правило, берут очередную библиотеку, которая была
написана непонятно кем, непонятно где и непонятно для чего и пытаются
совместить её с группой таких же библиотек, которые никак не согласованы
между собой и имеют избыточный и не до конца протестированный функционал.
В результате получается набор непонятных и не согласованных библиотек,
которые имеют плохо протестированный и избыточный функционал, который в
свою очередь постоянно растёт в объёме. К сожалению, многие разработчики
"погрязли" в таком коде и пытаются отрицать очевидные вещи.

Основной упор в системе сделан на получение максимальной производительности.
Оценочным критерием является простое и понятное условие: система,
установленная на хостинге с самым дешёвым тарифным планом, который
соответствует минимальным требованиям установки (от ~3-5$ в месяц),
должна генерировать главную страницу за 0,01 секунду (при
использовании OPCache + JIT и твердотельных накопителей), что даёт
возможность одновременно обслуживать до ~100 запросов в секунду.


Управление содержимым
---------------------------------------------------------------------

В системе пользователю доступен набор макетов. Каждый макет имеет определённое
количество регионов. В каждом регионе могут размещаться блоки с текстом, меню,
формы (только в регионе "content") и другие. Каждая страница может иметь
индивидуальный макет. Таким образом, разметка любой страницы может быть
уникальной.


Локализация
---------------------------------------------------------------------

В системе уже имеются переводы её интерфейса на Белорусский и Русский языки.
В административном интерфейсе системы в разделе "Управление → Локализации" можно
назначить основной язык интерфейса системы, а в разделе
"Управление → Данные → Содержимое → Страницы" для каждой страницы можно
назначить собственный язык.

Организовать мультиязычный веб-сайт/веб-портал можно двумя способами:

1) в рамках одного домена организовать столько копий страниц, меню,
   текстовых блоков и т.д. сколько языков необходимо поддерживать;
2) для каждого языкового домена организовать собственную языковую копию системы.

И первая и вторая версия предполагают наличие дубликатов страниц, меню, текстовых
блоков и другого контента на различных языках. Данный подход является оправданным т.к.
практически всегда разные языковые версии имеют отличия не только в содержании,
но и в структуре. Например, главное меню на одной языковой версии может иметь одни пункты меню,
а на другой — совсем иные, при этом будут отличаться и названия самих пунктов и их адреса и
количество этих пунктов.

В модуле "Профиль "Классика" Вы можете увидеть пример реализации
мультиязычности по способу №1.

Система использует более совершенную систему "Plural". С помощью регулярных выражений
можно описать практически любую зависимость части слова от присутствующих во фразе числовых
и не числовых аргументов.


Оформление
---------------------------------------------------------------------

В административном интерфейсе системы имеется раздел "Управление → Вид" который
отвечает за оформление страниц.

В подразделе "Цвета → Предустановки" можно выбрать и применить цветовые наборы
для элементов страницы, а в подразделе "Цвета → Текущие" изменить цвет конкретного элемента.
Количество цветов ограничено встроенной палитрой (дополнительные цвета можно получить путём
установки или создания собственного профиля).

В подразделе "Макеты" можно просмотреть имеющиеся в системе макеты страниц (дополнительные
макеты можно получить путём установки или создания собственного профиля).
Все макеты, имеющиеся в системе, а также декоратор с параметром "view_type = table-adaptive"
могут адаптироваться к изменению разрешения экрана и таким образом адаптироваться к отображению
данных на экранах мобильных устройств.

В подразделе "Глобальный CSS" можно описать свои собственные CSS-директивы и тем самым
внести изменения в оформление страниц.

В подразделе "Настройки" можно задать минимальную и максимальную ширину страниц при этом
в настройках уже непосредственно самих страниц эти параметры можно переопределить.


Профили
---------------------------------------------------------------------

В системе не существует привычных всем тем оформления. Для создания своего уникального
вида существует такой тип модуля как "Профиль" ("module_as_profile"). В профиле могут
быть описаны: страницы, меню, любые виды блоков (например, содержащие текст, аудио, видео,
галереи, выборки, опросы), цвета и их наборы, стили в виде файлов "*.css"/"*.cssd",
скрипты в виде файлов "*.js"/"*.jsd", макеты страниц, шаблоны элементов, любые виды файлов,
которые необходимо скопировать в систему при развёртывании профиля (изображения, аудио, видео,
"robots.txt", "sitemap.xml" и другие) и всё, что может реализовать любой типичный модуль.

В директории "profiles/examples" находятся примеры профилей, которые Вы можете скопировать
в директорию "modules" и производить с ними любые действия, не боясь потери данных (рекомендуется
переименовать все названия внутри профиля на свои собственные).

Создав профиль, Вы сможете производить развёртывание системы со своими настройками очень
просто — достаточно включить этот профиль в установленной системе (как и любой другой модуль),
или же на странице установки системы (если установка производится с нуля) выбрать свой
профиль из списка доступных.


Модули/Профили/Библиотеки
---------------------------------------------------------------------

Новые модули/профили/библиотеки необходимо размещать в директории "modules"
иначе при обновлении они будут потеряны — система Git очистит все директории до состояния
эталонной копии. По этой же причине нельзя вносить изменения в модули/профили, которые
располагаются в директории "system".

При копировании модулей в административном интерфейсе системы в разделе
"Управление → Модули → Установить" следует сбросить кэш (кнопка "↺") для того,
чтобы новые модули появились здесь же — в списке доступных модулей.

Для внедрения любой сторонней библиотеки на базе PHP или JS необходимо расположить
её файлы в обёртке пустого модуля и включить данный модуль после чего все файлы
библиотеки станут доступны.


Обновление
---------------------------------------------------------------------

Обновление системы предоставляет:

- новый функционал;
- исправления ошибок;
- улучшение производительности;
- улучшение безопасности.

Для обновления системы в ручном режиме необходимо зайти на её официальный
сайт effcore.com и загрузить текущую версию дистрибутива в виде архива.
Далее следует распаковать загруженный архив локально.
Важно: среди распакованных файлов Вы найдёте полупустые директории "modules" и "dynamic"
которые необходимо удалить до процесса копирования на веб-сервер!
Удалять их нужно потому, что в некоторых операционных системах при копировании
директорий происходит полная замена старых директорий на новые, а не их слияние,
что приведёт к утрате данных на веб-сервере.
Далее следует скопировать оставшиеся файлы на веб-сервер таким образом чтобы
новые файлы из дистрибутивы заменили старые файлы на веб-сервере.
После этого в административном интерфейсе системы следует посетить раздел
"Управление → Модули → Обновить → Данные" и выполнить обновление для каждого
модуля если это потребуется.

Для обновления системы через Git-репозиторий необходимо в административном интерфейсе
системы зайти в раздел "Управление → Модули → Обновить → Файлы из репозитория" и
выполнить обновление в одно нажатие кнопкой "обновить".
Если кнопка "обновить" недоступна, но доступна кнопка "восстановить репозиторий",
тогда необходимо выполнить процедуру восстановления репозитория.
Если недоступны кнопки "обновить" и "восстановить репозиторий" значит указанный
модуль не имеет собственного репозитория и его обновление через Git невозможно.

Процесс обновления через Git-репозиторий также можно выполнить из терминала/консоли/шелла
если зайти на веб-сервер через SSH соединение и перейти в директорию "shell" после чего
запустить скрипт "./update.sh". Такое обновление возможно только в случае, если в веб-корне
имеется директория ".git".


Улучшение производительности
---------------------------------------------------------------------

Для повышения производительности следует:

- в PHP v.7+ включить OPCache;
- в PHP v.8+ включить OPCache + JIT;
- перейти на использование твердотельных накопителей (англ. Solid-State Drive, SSD);
- перенести директории "dynamic/cache" и "dynamic/tmp" в ОЗУ при этом
  для повышения уровня надёжности веб-сервера такая ОЗУ должна поддерживать
  коррекцию ошибок (англ. error-correcting code, ECC), а сам сервер использовать
  источник бесперебойного питания (англ. Uninterruptible Power Supply, UPS).

Лучший способ увеличения производительности — это грамотное каскадирование стилей.
Такой подход позволяет обойтись без препроцессоров SAS и LESS, основной задачей
которых является копирование существующих стилей на множество новых элементов
в результате чего объём каждого CSS-файла начинает превышать 10-20КиБ.

Хороший способ увеличения производительности — это минификация JS-файлов путём
редукционной реорганизации кода сторонними программами или сервисами.
Также хорошим решением является отказ от "тяжёлых" библиотек подобных jQuery и переход
на CSS3-анимацию, SMIL-анимацию, современные возможности JavaScript и HTML5.

Несущественный способ увеличения производительности — это включить технологию
потокового сжатия GZIP. Сделать это можно средствами веб-сервера NGINX, Apache, IIS.
Однако следует помнить, что сжатие и распаковка GZIP-трафика приводит
к увеличению нагрузки на процессор, и как следствие, создаёт небольшую задержку
при загрузке и распаковке сжатого трафика, а также снижает время автономной
работы мобильного устройства. Скорости передачи информации в современные сетях
делают подобные оптимизации несущественными, а файлы размером 10-20КиБ
передаются практически мгновенно, что позволяет получать 100PSI в рейтинге
Google Page Speed без подобных оптимизаций.


Кэширование
---------------------------------------------------------------------

Архитектура ядра системы выполнена таким образом, чтобы сама система работала
максимально быстро и не требовала кэширования. Веб-сайты среднего уровня на базе
данной системы будут работать так же быстро, как и другие системы с включенным кэшем.
Для сильно нагруженных веб-порталов, возможно, потребуется кеширование и включить
его можно будет средствами веб-сервера NGINX, Apache, IIS (никакие дополнительные
действия со стороны системы не потребуются).


Лицензирование
---------------------------------------------------------------------

Система является открытой и бесплатной.

Система не является общественным достоянием.

Любое физическое лицо или организация вправе взять систему,
внести в неё изменения или оставить в неизменном виде,
далее на основе такой системы создать веб-сайт, веб-портал, веб-сервис
и разместить его на сервере (развёртывание), где система будет выполнять работу,
при этом программные файлы системы не должны стать общедоступными.

Физическое лицо или организация вправе распространять систему
в составе других продуктов только в неизменном виде.

Таким образом, лицензионное соглашение налагает запрет на
распространение системы в модифицированном виде, что делает вне закона
любую попытку выдать систему как собственное произведение.


Архитектура
---------------------------------------------------------------------

Архитектура выполнена по классической схеме MVC.
Является гибридной системой на базе NoSQL и SQL-хранилищ.
NoSQL-хранилище имеет уникальную реализацию и представляет собой гибрид из
документ-ориентированной, объектно-ориентированной и иерархической модели.
Ядро системы представляет собой набор классов-паттернов и NoSQL-дерево в виде PHP-кода,
содержащее экземпляры этих классов (сущностей) в древовидной форме с любым уровнем
вложенности и неограниченных по своей структуре.

Код системы адаптирован под повторное использование.
Система состоит из множества маленьких классов/классов-паттернов,
которые содержат в себе в среднем от 3 до 15 методов, которые, в свою очередь,
состоят из 3-15 строк кода. Восприятие кода существенно облегчается благодаря
"матричному" стилю вёрстки (в некоторых местах напоминает синтаксис Python).
Всё, что казалось сложным, было отвергнуто или переделано.
Каждая функция итеративно совершенствовалась от 3 до 10 раз.
Функциональное тестирование выполнялось на всём множестве
комбинаторных перестановок.

В состав системы входит страница с UML-диаграммой всех классов
и ссылкой для загрузки JSON-файла с описанием классов в формате
программы StarUML.


Файловая организация
---------------------------------------------------------------------

Грамотное расположение файлов в системе позволяет определить их назначение,
не прибегая к документации.

В директориях вида "module_*/frontend" располагается всё необходимое для frontend-разработки.
В директориях вида "module_*/backend" располагается всё необходимое для backend-разработки.
В директориях вида "module_*/data" располагаются NoSQL-данные.

Фактически, работа файлов не зависит от их расположения и при необходимости они всё равно
будут найдены и обработаны. Расположение файлов в определённых директориях — это лишь
организационная мера, призванная облегчить работу с системой.

Система имеет встроенный парсер и загрузчик классов PSR-0.


NoSQL
---------------------------------------------------------------------

Все NoSQL-данные хранятся в файлах "*.data" которые имеются в каждом модуле.
Каждый такой файл может описывать один или множество экземпляров любых видов
сущностей с любым уровнем вложенности друг в друга (структура дерева).
Каждая строка такого файла описывает единичный атрибут сущности и может принимать
виды: "имя", "имя|имя_класса", "ключ: значение", "- свойство: значение".
Пример такой структуры показан ниже.

Пример "*.data"-файла:

    demo
      object_1|class_name
        property_1: value 1
        property_2: value 2 …
        property_N: value N
      array_1
      - key_1: value 1
      - key_2: value 2 …
      - key_N: value N

После очистки кэша специальный механизм находит каждый такой файл в директориях "modules"
и "system", производит его разбор, преобразует в PHP-код и распределяет по файлам в директории
"dynamic/cache". Вся процедура занимает несколько секунд и выполняется только в случае
внесения изменений в глобальное NoSQL-дерево (как правило при сохранении системных настроек
через административный интерфейс). Пример такого PHP-файла показан ниже.

    namespace effcore {
      cache::$data['demo'] = new \stdClass;
      cache::$data['demo']->object_1 = new class_name;
      cache::$data['demo']->object_1->property_1 = 'value 1';
      cache::$data['demo']->object_1->property_2 = 'value 2';
      cache::$data['demo']->object_1->property_N = 'value N';
      cache::$data['demo']->array_1['key_1'] = 'value 1';
      cache::$data['demo']->array_1['key_2'] = 'value 2';
      cache::$data['demo']->array_1['key_N'] = 'value N';
    }

Хранение данных в директории "dynamic/cache" производится раздельно для каждого
вида сущности как показано на примере ниже.

Пример раздельного хранения сущностей:

- dynamic/cache/data--blocks.php
- dynamic/cache/data--breadcrumbs.php
- dynamic/cache/data--file_types.php

Далее при попытке вызова определённой части NoSQL-дерева происходит включение
необходимого PHP-файла и запрашиваемые данные становятся мгновенно-доступными.
При использовании OPCache все данные уже находятся в виде байт-кода и вероятно
в ОЗУ в кэше PHP, что делает доступ к ним настолько быстрым насколько это
возможно в принципе.

Такая структура файла очень удобна для разработки т.к. любое изменение любого
атрибута будет показано через "git diff" как изменение 1 строки в определённо месте
определённого файла.

Изменять структуру NoSQL-дерева можно через специальный механизм "Changes".
Данный механизм предоставляет возможность вносить изменения в глобальное NoSQL-дерево
на базе которого работает вся система. Пример внесения изменений показан
в файле "demo--data--changes.data" модуля "Демо". После применения механизма
и очистки кэша произойдёт перестройка всего дерева.

NoSQL-хранилище поддерживает следующие типы данных:

- integer;
- float;
- boolean;
- string;
- string|_string_true;
- string|_string_false;
- array;
- array|_empty_array
- object|class_name;
- null.

Примечание: системное меню расположено в NoSQL-хранилище и никто не может
нарушить его работу при помощи административного интерфейса системы. Меню
анонимного пользователя хранится в SQL-хранилище, и его редактирование
доступно через административный интерфейс системы.


SQL
---------------------------------------------------------------------

В качестве SQL-хранилища могут быть использованы MySQL и SQLite.
Требуемые версии можно узнать в файле "readme/software.md".

Поддерживаются следующие возможности:

- проверки "checks" (SQLite, MySQL v.8+);
- транзакции ("begin", "rollback", "commit");
- сопоставления "collate" ("nocase", "binary");
- ограничения "constraints" ("primary", "unique", "foreign" с каскадным действием);
- простые и уникальные индексы ("index", "unique index");
- подключение к дополнительным хранилищам через процесс ручной инициализации;
- префиксы таблиц.

Поддержка каскадных действий внешнего ключа:

- на обновление: "cascade" (не были протестированы: "restrict", "no action");
- на удаление: "cascade" (не были протестированы: "restrict", "no action").

Поддерживаются кроссплатформенные типы полей:

- autoincrement;
- varchar  (MySQL: varchar  | SQLite: text);
- integer  (MySQL: int      | SQLite: integer);
- real     (MySQL: double   | SQLite: real);
- time     (MySQL: time     | SQLite: text);
- date     (MySQL: date     | SQLite: text);
- datetime (MySQL: datetime | SQLite: text);
- boolean  (MySQL: tinyint  | SQLite: integer);
- blob     (MySQL: blob     | SQLite: blob).

Указанных типов достаточно для большинства задач.
Другие типы допускаются, но они не были протестированы.
Рекомендуется использовать только эти типы для обеспечения
кроссплатформенной совместимости.

Основной упор сделан на ANSI SQL и кроссплатформенность.
В процессе разработки был исключён PostgreSQL как СУРБД, наименее
соответствующая ANSI-стандартам и имеющая особенности в работе
со счётчиками "autoincrement".

Для хранения дат и времени было принято решение использовать типы: "time", "date", "datetime".
Тип "date" имеет больший диапазон допустимых значений (от "0001-01-01" до "9999-12-31"),
а также не имеет автоматического преобразования часового пояса.
При добавлении дат в хранилище их следует преобразовывать к часовому поясу UTC±0:00.
Было принято решение отказаться от типа "timestamp" из-за автоматического преобразования
часового пояса и вместо него использовать тип "integer".

Распределённые запросы к удалённым хранилищам не поддерживаются.

Примечание 1: SQLite поддерживает только 4 типа данных: "integer", "real", "text", "blob".
Всё, что может быть представлено в виде числа (например, "boolean"), будет автоматически
преобразовываться к типу "integer" и с другими типами по такой же аналогии.
Такая реализация не проводит контроля целостности домена данных, однако данная
система осуществляет такой контроль на стороне полей форм и внести недействительные
значения будет невозможно.

Примечание 2: MySQL до версии 8 не поддерживал "check", однако данная
система осуществляет такой контроль на стороне полей форм и внести недействительные
значения будет невозможно.


CSSD, JSD
---------------------------------------------------------------------

Единая точка входа предоставляет системе возможность контролировать процесс выдачи
содержимого любого файла, благодаря чему стало возможным использование переменных
в "*.cssd" и "*.jsd" файлах.


Событийная модель
---------------------------------------------------------------------

Система имеет прозрачную и предсказуемую событийную модель.
Достаточно зарегистрировать новое событие в "events.data" вашего модуля, указать
его вес и обработчик в PHP-коде, сбросить кэш, и событие начнёт обрабатываться.
В административном интерфейсе системы в разделе "Разработка → NoSQL данные → События"
можно просмотреть все зарегистрированные в системе события (раздел "Разработка" станет
доступен после включения модуля "Разработка").

