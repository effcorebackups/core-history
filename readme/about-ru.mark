

                       ○○○○   ○○○○
                     ○○○○○  ○○○○○○
                    ○○○    ○○○
        ○○○○○○○     ○○○○○○○○○○○○○○  ○○○○○○○      ○○○○○○○     ○○ ○○○   ○○○○○○○
      ○○○○   ○○○○   ○○○○○○○○○○○○  ○○○     ○○○  ○○○     ○○○   ○○○    ○○○     ○○○
     ○○○       ○○○  ○○○    ○○○   ○○           ○○         ○○  ○○    ○○         ○○
    ○○○○○○○○○○○○○○  ○○○    ○○○  ○○           ○○           ○○ ○○   ○○○○○○○○○○○○○○
     ○○○            ○○○    ○○○   ○○           ○○         ○○  ○○    ○○
      ○○○○   ○○○○   ○○○    ○○○    ○○○     ○○○  ○○○     ○○○   ○○     ○○○     ○○○
        ○○○○○○○     ○○○    ○○○      ○○○○○○○      ○○○○○○○     ○○       ○○○○○○○
                  ○○○○   ○○○○
                ○○○○   ○○○○                Copyright © 2017—2020 Maxim Rysevets.


О ПРОЕКТЕ
=====================================================================

effcore - система нового поколения, разработанная в начале 20-ых годов.
Вобрала в себя все новые технологии Web 2.0/3.0 включая HTML5, CSS3, JS ES6,
IP v6, SVG, SMIL, UTF8, UTC.

Целевое назначение - использование в качестве инструмента для построения
сайтов простыми пользователями, а также в качестве инструмента для
разработки сайтов и порталов профессиональными веб-разработчиками.

Архитектура выполнена по классической схеме MVC.
В тоже время является гибридной системой из NoSQL и SQL хранилищ и набора
классов/классов-паттернов.

Была разработана с нуля. Её главный принцип - полное отсутствие
стороннего кода (для исключения правовых претензий, а также любых
других ограничений, связанных с заимствованием),
а также сторонних идей (для поиска новых инновационных решений).

Код системы адаптирован под повторное использование.
Система состоит из множества маленьких классов/классов-паттернов,
содержащих в себе в среднем от 3 до 15 методов,
состоящих в среднем из 3-7 строк кода.

Основной упор сделан на легкое восприятие как самого кода (в некоторых
местах напоминающий Python, а также благодаря "матричному" стилю вёрстки кода),
так и всей структуры файлов (всё необходимое для frontend разработки
хранится в директории frontend, аналогично и для backend).
Таким образом разработчик любого уровня может легко воспринимать
элементы системы не прибегая к комментариям.
Функциональное тестирование выполнялось на всём множестве комбинаторных перестановок.
Каждая функция итеративно совершенствовалась от 3 до 10 раз.

Основной упор в системе сделан на получение максимально возможной производительности.
В качестве оценочных критериев было принято следующее условие:
система, установленная на хостинге с самым дешёвым тарифным планом,
но соответствующего минимальным требованиям установки (от 3$ в месяц),
должна генерировать главную страницу за время 0,002 секунды (с включенным
OPcache) или 0,02 секунды (с выключенным OPcache), что в первом случае
позволяет обслуживать до ≈500 клиентов в секунду, а во втором до ≈50 (без
учёта параллельной загрузки дополнительного контента в виде JS и CSS).

Также немаловажным фактором в системе стала безопасность.
В качестве решений для повышения уровня безопасности были использованы:
- возможность работы без JS;
- подписанные ключом пользовательские сессии;
- подписанные ключом валидационные идентификаторы формы;
- использование препарированных SQL запросов;
- фильтрация данных, вводимых пользователем в поля формы;
- фильтрация аргументов URL;
- единая точка входа любого http запроса (single entry point),
  как результат - отсутсвие негативных воздействий при неверной настройке
  веб-сервера (.htaccess, web.config);
- возможность создания нового типа файла с полным контролем доступа;
- базовый модуль CAPTCHA.

Имеет встроенный парсер и загрузчик классов PSR-0, благодаря чему
для добавления новой библиотеки (набора классов) достаточно поместить
содержащие их файлы на веб-сервер и сбросить кэш, после чего они
становятся доступными из любого места системы.
В состав системы входит страница с UML диаграммой всех классов
и ссылкой для загрузки json-файла с описанием классов в формате
программы StarUML.

Любой экземпляр класса и другие NoSQL-данные могут быть описаны в текстовом
формате в файле вида *.data, подобном YAML, однако имеющем более строгие
правила такие как "каждая строка может содержать только одну
фразу вида "ключ: значение", что удобно для контроля изменений
в коде (любое изменение одного ключа или значения будет выделяться
в git diff только одной строкой), а также существенно ускоряет
парсинг таких файлов.
Ниже приведён пример *.data файла.

    demo
      object_1|class_name
        property_1: value 1
        property_2: value 2 …
        property_N: value N
      array_1
      - item_1: value 1
      - item_2: value 2 …
      - item_N: value N

При этом и объекты (экземпляры классов-паттернов) и массивы могут иметь
любые уровни вложенности и содержать в себе любые другие объекты или
массивы.

После парсинга *.data файлов результат преобразуется
в PHP код (единое дерево объектов - экземпляров классов-патернов),
после чего сохраняется в файлы cache-*.php директории dynamic/cache
в отдельном файле для каждого вида сущности, как показано в примере ниже:
- dynamic/cache/data--blocks.php
- dynamic/cache/data--breadcrumbs.php
- dynamic/cache/data--file_types.php
и так далее.

Описанный выше пример будет преобразован в PHP файл следующего вида: 

    namespace effcore {
      cache::$data['demo'] = new \stdClass;
      cache::$data['demo']->object_1 = new class_name;
      cache::$data['demo']->object_1->property_1 = 'value 1';
      cache::$data['demo']->object_1->property_2 = 'value 2';
      cache::$data['demo']->object_1->property_N = 'value N';
      cache::$data['demo']->array_1['item_1'] = 'value 1';
      cache::$data['demo']->array_1['item_2'] = 'value 2';
      cache::$data['demo']->array_1['item_N'] = 'value N';
    }

Такая архитектура позволяет получать доступ к NoSQL данным настолько быстро,
насколько это возможно. При использовании PHP модуля OPcache скорость доступа
может возрасти от 2 до 3 раз.
По сути для доступа к NoSQL данным достаточно загрузить PHP файл
определенной сущности и данные станут доступны сразу же после загрузки.

Таким образом ядро системы составляет вышеупомянутый набор классов-паттернов,
а также NoSQL хранилище, кэш которого представлен в виде PHP кода,
содержащего экземпляры этих классов в древовидной форме с любым уровнем
вложенности и неограниченных по своей структуре.

Благодаря такой архитектуре не требуется кеширование.
Для больших проектов кеширование обычно выполняется сторонними средствами
веб-сервера, что изначально предполагается автором.

В качестве SQL хранилища могут быть использованы MySQL и SQLite.
Подключение к хранилищу и выборка данных осуществляется лишь по требованию.
Отказ SQL хранилища не приведет к выдаче ошибки, а лишь сделает недоступными
часть возможностей (например, отключатся сессии и вход в систему,
а на страницах с выборками будет показано "0 результатов").
Поддерживаются транзакции, внешние ключи (foreign keys) с каскадным действием,
а также проверки (checks).
Основной упор сделан на ANSI SQL.
В процессе разработки был исключён PostgreSQL как наименее соотвествующий
ANSI стандартам СУРБД в веб-среде.

Единая точка входа (single entry point) даёт возможность системе
контролировать процесс выдачи содержимого любого файла, благодаря чему
стало возможным использование внешних переменных в CSS и JS файлах.
Такие переменные начинаются с "%%_", а содержащие их файлы имеют
расширения *.cssd и *.jsd.

Проект не реализует и считает технологию потокового сжатия CSS и JS
устаревшей в силу следующих причин:
- сжатию подвергаются текстовые файлы в объёме от 1 до 10 килобайт,
  что при современной скорости передачи данных не существенно,
  при этом на сжатие затрачиваются ресурсы веб-сервера,
  а на распаковку - клиента (что в итоге сказывается и на заряде
  батарей мобильных клиентов);
- для CSS объём файла выше 10 килобайт считает следствием неправильного
  каскадирования стилей, вкупе с использованием такой пагубной технологии
  как SASS или LESS, потворствующей "бракодированию";
- JS файлы могут быть сжаты и обфусцированы изначально путем редукционной
  реорганизации JS кода сторонними программами или сервисами.
Однако никто не мешает использовать возможности потокового сжатия
непосредственно веб-сервера.

